name: Bot Pickleball For ME

env:
  TARGET_UTC_HOUR : 15
  ADVANCE_SECONDS : 1
  MAX_WAIT_SECONDS: 600     # Seuil maximum d'attente (600 = 10 min, 1800 = 30 min, etc.)
  REGISTRATION_JSON_FILE: 'my_registrations.json'  # ‚Üê Change ici
  TAG_PREFIX: 'my'  # ‚Üê Change 'my' ou 'his'
  TARGET_NAME_SECRET: 'YOUR_SECRET_MY_NAME'  # ‚Üê 'YOUR_SECRET_MY_NAME' ou 'YOUR_SECRET_HIS_NAME'

permissions:
  contents: write
  actions: read



on:
  schedule:
    - cron: '00 14 * * *' # 23:45  Sunday is 0 Saturday 6
    - cron: '12 14 * * *' # 23:55 Calgary
    - cron: '24 14 * * *' # 23:55 Calgary
    - cron: '36 14 * * *' # 23:55 Calgary
    - cron: '48 14 * * *' # 23:55 Calgary
    - cron: '55 14 * * *' # 23:55 Calgary


    - cron: '0 15 * * *' # 00:00 Calgary
  #  - cron: '40 13 * * *' # 23:45  Sunday is 0 Saturday 6
  #  - cron: '50 13 * * *' # 23:55 Calgary
  #  - cron: '0 14 * * *' # 00:00 Calgary

  workflow_dispatch:  # Ajoutez cette ligne
    inputs:
      date:
        description: 'Date (DD-Mth-YY)'
        required: true
      time:
        description: 'Time (HH:MM)'
        required: true
      level:
        description: 'Level'
        required: true
      name:
        description: 'Name'
        required: true


#limitation expect registration to begin a 6 UTC"

jobs:
  register:
    runs-on: ubuntu-latest
    # Utilise ton image Docker personnalis√©e
    container:
      image: scalgary/selenium-env:latest
      options: --workdir ${{ github.workspace }}
    steps:
      # ==========================================
      # STEP 1: Checkout code and fetch tags
      # ==========================================
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Load registration from JSON
        id: params
        shell: bash

        run: |
         echo "======================================"
         echo "üìñ Loading registration from JSON"
         echo "======================================"
         # Si manuel, utiliser les inputs
         if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
           echo "üîß Manual trigger - using inputs"
           date="${{ inputs.date }}"
           time="${{ inputs.time }}"
           level="${{ inputs.level }}"
           day=$(date -d "$date" +%A)
         else

           # R√©cup√©rer le jour actuel
           current_day=$(date -u +%A)
           echo "üìÖ Current day (UTC): $current_day"
    
           # Chercher la registration pour aujourd'hui (AJOUTE level)
           json_file="${{ env.REGISTRATION_JSON_FILE }}"
          echo "üìÑ Using: $json_file"

          registration=$(jq -r --arg day "$current_day" \
          '.[] | select(.day == $day) | "\(.date)|\(.time)|\(.day)|\(.level)"' \
          "$json_file" | head -1)


           # V√©rifier si une registration existe
           if [ -z "$registration" ]; then
            echo "‚ùå No registration found for $current_day"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            exit 0
           fi

    
           # Split et afficher
           IFS='|' read -r date time day level<<< "$registration"
           echo "‚úÖ Registration found:"
           echo "   üìÖ Date: $date"
           echo "   üïê Time: $time"
           echo "   üìÜ Day: $day"
           echo "   üéæ Level: $level"
         fi

    
         # Exporter vers GITHUB_OUTPUT
         echo "date=$date" >> $GITHUB_OUTPUT
         echo "time=$time" >> $GITHUB_OUTPUT
         echo "day=$day" >> $GITHUB_OUTPUT
         echo "level=$level" >> $GITHUB_OUTPUT

         echo "should_continue=true" >> $GITHUB_OUTPUT
    
         echo "======================================"

    

      - name: Git setup and fetch tags
        if: steps.params.outputs.should_continue == 'true'
        run: |
          pwd
          ls -la
          echo "üîß Configuring Git..."
          git config --global --add safe.directory $GITHUB_WORKSPACE
          git config user.name "bot"
          git config user.email "bot@github.com"
          echo "üè∑Ô∏è Fetching tags from remote..."
          git fetch --tags
          echo "‚úÖ Tags fetched successfully"

      # ==========================================
      # STEP 2: Check tag and timing
      # ==========================================
      - name: Check tag & timing
        id: check
        shell: bash
        if: steps.params.outputs.should_continue == 'true'
        run: |
          echo "======================================"
          echo "üïê Checking timing and tags"
          echo "======================================"
          # R√©cup√©rer les param√®tres
          TARGET_HOUR=${{ env.TARGET_UTC_HOUR }}
          ADVANCE_SEC=${{ env.ADVANCE_SECONDS }}
          MAX_WAIT=${{ env.MAX_WAIT_SECONDS }}

          echo "üéØ Target UTC hour: ${TARGET_HOUR}:00"
          echo "‚è∞ Will start ${ADVANCE_SEC} seconds early"

          # POUR TEST MANUEL SEULEMENT
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "üß™ Manual run detected - skipping timing check"
            echo "should_continue=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          target_date="${{ steps.params.outputs.date }}"
          prefix="${{ env.TAG_PREFIX }}"
          tag="${prefix}_bot_success_${target_date}"
          echo "üè∑Ô∏è Tag prefix: $prefix"
          echo "üîç Looking for tag: $tag"
          
          # Check if tag already exists
          if git tag -l | grep -q "^${tag}$"; then
            echo "üè∑Ô∏è ‚úÖ Success tag already exists: $tag"
            echo "üõë Stopping workflow (success already registered)"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "üìù Tag not found, continuing..."
          
          # Get current UTC time
          current_hour=$((10#$(date -u +%H)))
          current_minute=$((10#$(date -u +%M)))
          current_second=$((10#$(date -u +%S)))
          current_total_seconds=$(( (current_hour * 3600) + (current_minute * 60) + current_second ))

          echo "üïê Current UTC time: ${current_hour}:${current_minute}:${current_second}"
          
          # Calcul avec l'avance
          target_total_seconds=$(( (TARGET_HOUR * 3600) - ADVANCE_SEC ))
          diff_seconds=$(( target_total_seconds - current_total_seconds ))
          diff_minutes=$(( diff_seconds / 60 ))
          echo "‚è±Ô∏è Difference: $diff_seconds seconds ($diff_minutes minutes) avant l'heure cible"

          # Timing logic
          if [ $diff_seconds -gt $MAX_WAIT ]; then
            echo "‚ùå Too early: $diff_seconds seconds remaining (> 10 minutes)"
            echo "üõë Stopping workflow"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            exit 0

          else
            echo "‚úÖ Within acceptable wait time (< $MAX_WAIT seconds)"
            echo "üì¶ Le conteneur sera d√©marr√©"
            echo "‚è∞ L'attente finale se fera DANS le conteneur"
            echo "should_continue=true" >> $GITHUB_OUTPUT
          fi


          echo "======================================"

      # ==========================================
      # STEP 3: Registration attempt
      # ==========================================
      - name: Register
        id: registration
        if: steps.check.outputs.should_continue == 'true'
        shell: bash
        env:
          TARGET_DATE: ${{ steps.params.outputs.date }}
          TARGET_TIME: ${{ steps.params.outputs.time }}
          TARGET_DAY: ${{ steps.params.outputs.day }}
          YOUR_SECRET_EMAIL: ${{ secrets.YOUR_SECRET_EMAIL }}
          YOUR_SECRET_PASSWORD: ${{ secrets.YOUR_SECRET_PASSWORD }}
          YOUR_SECRET_LOGON_URL: ${{ secrets.YOUR_SECRET_LOGON_URL }}
          YOUR_SECRET_PLANNING_URL: ${{ secrets.YOUR_SECRET_PLANNING_URL }}
          YOUR_SECRET_LOGIN_URL: ${{ secrets.YOUR_SECRET_LOGIN_URL }}
          YOUR_SECRET_MY_NAME: ${{ secrets.YOUR_SECRET_MY_NAME }}
          YOUR_SECRET_HIS_NAME: ${{ secrets.YOUR_SECRET_HIS_NAME }}
          YOUR_SECRET_APPOINTMENT: ${{ secrets.YOUR_SECRET_APPOINTMENT }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          CALDAV_PASSWORD:  ${{ secrets.CALDAV_PASSWORD }}
          CALDAV_USER: ${{ secrets.CALDAV_USER }}



        run: |
            echo "======================================"
            echo "üéæ Pickleball Registration Attempt"
            echo "======================================"
            # R√©cup√©rer l'heure cible
            TARGET_HOUR=${{ env.TARGET_UTC_HOUR }}
            ADVANCE_SEC=${{ env.ADVANCE_SECONDS }}
            MAX_WAIT=${{ env.MAX_WAIT_SECONDS }}
            # D√©terminer quel nom utiliser
            if [ "${{ env.TARGET_NAME_SECRET }}" = "YOUR_SECRET_MY_NAME" ]; then
            TARGET_NAME="${{ secrets.YOUR_SECRET_MY_NAME }}"
            else
            TARGET_NAME="${{ secrets.YOUR_SECRET_HIS_NAME }}"
            fi

            echo "üë§ Using name from: ${{ env.TARGET_NAME_SECRET }}"


            echo "üìã Configuration:"
            echo "   üéØ Target: ${TARGET_HOUR}:00:00 UTC"
            echo "   ‚è∞ Advance: ${ADVANCE_SEC} seconds"
            echo "   ‚è≥ Max wait: ${MAX_WAIT} seconds"

            # ‚è∞ ATTENTE JUSQU'√Ä L'HEURE CIBLE (MOINS L'AVANCE)
            if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
              current_hour=$((10#$(date -u +%H)))
              current_minute=$((10#$(date -u +%M)))
              current_second=$((10#$(date -u +%S)))
              current_total_seconds=$(( (current_hour * 3600) + (current_minute * 60) + current_second ))
              
              # Calcul avec l'avance
              target_total_seconds=$(( (TARGET_HOUR * 3600) - ADVANCE_SEC ))
              diff_seconds=$(( target_total_seconds - current_total_seconds ))
              
              echo "üïê Current UTC time: ${current_hour}:${current_minute}:${current_second}"
              if [ $diff_seconds -gt 0 ]; then
                echo "‚è∞ Waiting $diff_seconds seconds..."
                
                # Calcul de l'heure de r√©veil pr√©vue
                wake_hour=$(( (target_total_seconds / 3600) % 24 ))
                wake_minute=$(( (target_total_seconds % 3600) / 60 ))
                wake_second=$(( target_total_seconds % 60 ))
                printf "   Wake up scheduled at: %02d:%02d:%02d UTC\n" $wake_hour $wake_minute $wake_second
                
                sleep $diff_seconds
                
                # Afficher l'heure exacte du r√©veil
                actual_time=$(date -u +"%H:%M:%S")
                echo "‚úÖ Woke up at: $actual_time UTC"
                echo "   (${ADVANCE_SEC} seconds before ${TARGET_HOUR}:00:00)"
              else
                echo "‚ö†Ô∏è Already past target time (by $((-diff_seconds)) seconds)"
              fi
            else
              echo "üß™ Manual run: skipping wait"
            fi

            echo "üìÖ Date: ${{ steps.params.outputs.date }}"
            echo "üïê Time: ${{ steps.params.outputs.time }}"

            echo "Pickleball Registration: ${{ steps.params.outputs.day }}"
            python3 bot_execution.py "${{ steps.params.outputs.date }}" "${{ steps.params.outputs.time }}" "${{ steps.params.outputs.level }}" "$TARGET_NAME"
            FINAL_CODE=$?

            if [ $FINAL_CODE -eq 0 ]; then
                echo "‚úÖ Registration successful!"
            else
                echo "‚ùå Registration failed"
            fi

            echo ""
            echo "üìä Final code: $FINAL_CODE"
            echo "PYTHON_EXIT_CODE=$FINAL_CODE" >> $GITHUB_OUTPUT
            echo "======================================"


            exit 0

      # ==========================================
      # STEP 4: Create success tag
      # ==========================================
      - name: Tag success
        if: steps.check.outputs.should_continue == 'true' && steps.registration.outputs.PYTHON_EXIT_CODE == '0'
        run: |
          echo "======================================"
          echo "üè∑Ô∏è Creating success tag"
          echo "======================================"
          target_date="${{ steps.params.outputs.date }}"
          prefix="${{ env.TAG_PREFIX }}"
          tag="${prefix}_bot_success_${target_date}"


          echo "üìù Tag to create: $tag"
          git pull
          # git add all_appointments.json
          git commit --allow-empty -m "‚úÖ $tag"
          #git commit -m "‚úÖ $tag"
          git tag "$tag"
          
          echo "üì§ Pushing tag to remote..."
          git push origin HEAD "$tag"
          echo "‚úÖ Tag pushed successfully!"
          echo "======================================"
